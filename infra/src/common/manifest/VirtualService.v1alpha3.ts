/* tslint:disable */
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export interface VirtualService {
  /**
   * Configuration affecting label/content routing, sni routing, etc. See more details at: https://istio.io/docs/reference/config/networking/virtual-service.html
   */
  spec: {
    /**
     * A list of namespaces to which this virtual service is exported.
     */
    exportTo?: string[];
    /**
     * The names of gateways and sidecars that should apply these routes.
     */
    gateways?: string[];
    /**
     * The destination hosts to which traffic is being sent.
     */
    hosts?: string[];
    /**
     * An ordered list of route rules for HTTP traffic.
     */
    http?: {
      /**
       * Cross-Origin Resource Sharing policy (CORS).
       */
      corsPolicy?: {
        allowCredentials?: boolean;
        allowHeaders?: string[];
        /**
         * List of HTTP methods allowed to access the resource.
         */
        allowMethods?: string[];
        /**
         * The list of origins that are allowed to perform CORS requests.
         */
        allowOrigin?: string[];
        /**
         * String patterns that match allowed origins.
         */
        allowOrigins?: (
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
        )[];
        exposeHeaders?: string[];
        maxAge?: string;
        [k: string]: unknown;
      };
      delegate?: {
        /**
         * Name specifies the name of the delegate VirtualService.
         */
        name?: string;
        /**
         * Namespace specifies the namespace where the delegate VirtualService resides.
         */
        namespace?: string;
        [k: string]: unknown;
      };
      /**
       * Fault injection policy to apply on HTTP traffic at the client side.
       */
      fault?: {
        abort?:
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            };
        delay?:
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            };
        [k: string]: unknown;
      };
      headers?: {
        request?: {
          add?: {
            [k: string]: string;
          };
          remove?: string[];
          set?: {
            [k: string]: string;
          };
          [k: string]: unknown;
        };
        response?: {
          add?: {
            [k: string]: string;
          };
          remove?: string[];
          set?: {
            [k: string]: string;
          };
          [k: string]: unknown;
        };
        [k: string]: unknown;
      };
      match?: {
        authority?:
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            };
        /**
         * Names of gateways where the rule should be applied.
         */
        gateways?: string[];
        headers?: {
          [k: string]:
            | {
                [k: string]: unknown;
              }
            | {
                [k: string]: unknown;
              }
            | {
                [k: string]: unknown;
              }
            | {
                [k: string]: unknown;
              };
        };
        /**
         * Flag to specify whether the URI matching should be case-insensitive.
         */
        ignoreUriCase?: boolean;
        method?:
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            };
        /**
         * The name assigned to a match.
         */
        name?: string;
        /**
         * Specifies the ports on the host that is being addressed.
         */
        port?: number;
        /**
         * Query parameters for matching.
         */
        queryParams?: {
          [k: string]:
            | {
                [k: string]: unknown;
              }
            | {
                [k: string]: unknown;
              }
            | {
                [k: string]: unknown;
              }
            | {
                [k: string]: unknown;
              };
        };
        scheme?:
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            };
        sourceLabels?: {
          [k: string]: string;
        };
        /**
         * Source namespace constraining the applicability of a rule to workloads in that namespace.
         */
        sourceNamespace?: string;
        uri?:
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            }
          | {
              [k: string]: unknown;
            };
        /**
         * withoutHeader has the same syntax with the header, but has opposite meaning.
         */
        withoutHeaders?: {
          [k: string]:
            | {
                [k: string]: unknown;
              }
            | {
                [k: string]: unknown;
              }
            | {
                [k: string]: unknown;
              }
            | {
                [k: string]: unknown;
              };
        };
        [k: string]: unknown;
      }[];
      mirror?: {
        /**
         * The name of a service from the service registry.
         */
        host?: string;
        /**
         * Specifies the port on the host that is being addressed.
         */
        port?: {
          number?: number;
          [k: string]: unknown;
        };
        /**
         * The name of a subset within the service.
         */
        subset?: string;
        [k: string]: unknown;
      };
      /**
       * Percentage of the traffic to be mirrored by the `mirror` field.
       */
      mirrorPercent?: number;
      /**
       * Percentage of the traffic to be mirrored by the `mirror` field.
       */
      mirrorPercentage?: {
        value?: number;
        [k: string]: unknown;
      };
      /**
       * Percentage of the traffic to be mirrored by the `mirror` field.
       */
      mirror_percent?: number;
      /**
       * The name assigned to the route for debugging purposes.
       */
      name?: string;
      /**
       * A HTTP rule can either redirect or forward (default) traffic.
       */
      redirect?: {
        authority?: string;
        redirectCode?: number;
        uri?: string;
        [k: string]: unknown;
      };
      /**
       * Retry policy for HTTP requests.
       */
      retries?: {
        /**
         * Number of retries to be allowed for a given request.
         */
        attempts?: number;
        /**
         * Timeout per attempt for a given request, including the initial call and any retries.
         */
        perTryTimeout?: string;
        /**
         * Specifies the conditions under which retry takes place.
         */
        retryOn?: string;
        /**
         * Flag to specify whether the retries should retry to other localities.
         */
        retryRemoteLocalities?: boolean;
        [k: string]: unknown;
      };
      /**
       * Rewrite HTTP URIs and Authority headers.
       */
      rewrite?: {
        /**
         * rewrite the Authority/Host header with this value.
         */
        authority?: string;
        uri?: string;
        [k: string]: unknown;
      };
      /**
       * A HTTP rule can either redirect or forward (default) traffic.
       */
      route?: {
        destination?: {
          /**
           * The name of a service from the service registry.
           */
          host?: string;
          /**
           * Specifies the port on the host that is being addressed.
           */
          port?: {
            number?: number;
            [k: string]: unknown;
          };
          /**
           * The name of a subset within the service.
           */
          subset?: string;
          [k: string]: unknown;
        };
        headers?: {
          request?: {
            add?: {
              [k: string]: string;
            };
            remove?: string[];
            set?: {
              [k: string]: string;
            };
            [k: string]: unknown;
          };
          response?: {
            add?: {
              [k: string]: string;
            };
            remove?: string[];
            set?: {
              [k: string]: string;
            };
            [k: string]: unknown;
          };
          [k: string]: unknown;
        };
        weight?: number;
        [k: string]: unknown;
      }[];
      /**
       * Timeout for HTTP requests, default is disabled.
       */
      timeout?: string;
      [k: string]: unknown;
    }[];
    /**
     * An ordered list of route rules for opaque TCP traffic.
     */
    tcp?: {
      match?: {
        /**
         * IPv4 or IPv6 ip addresses of destination with optional subnet.
         */
        destinationSubnets?: string[];
        /**
         * Names of gateways where the rule should be applied.
         */
        gateways?: string[];
        /**
         * Specifies the port on the host that is being addressed.
         */
        port?: number;
        sourceLabels?: {
          [k: string]: string;
        };
        /**
         * Source namespace constraining the applicability of a rule to workloads in that namespace.
         */
        sourceNamespace?: string;
        /**
         * IPv4 or IPv6 ip address of source with optional subnet.
         */
        sourceSubnet?: string;
        [k: string]: unknown;
      }[];
      /**
       * The destination to which the connection should be forwarded to.
       */
      route?: {
        destination?: {
          /**
           * The name of a service from the service registry.
           */
          host?: string;
          /**
           * Specifies the port on the host that is being addressed.
           */
          port?: {
            number?: number;
            [k: string]: unknown;
          };
          /**
           * The name of a subset within the service.
           */
          subset?: string;
          [k: string]: unknown;
        };
        weight?: number;
        [k: string]: unknown;
      }[];
      [k: string]: unknown;
    }[];
    tls?: {
      match?: {
        /**
         * IPv4 or IPv6 ip addresses of destination with optional subnet.
         */
        destinationSubnets?: string[];
        /**
         * Names of gateways where the rule should be applied.
         */
        gateways?: string[];
        /**
         * Specifies the port on the host that is being addressed.
         */
        port?: number;
        /**
         * SNI (server name indicator) to match on.
         */
        sniHosts?: string[];
        sourceLabels?: {
          [k: string]: string;
        };
        /**
         * Source namespace constraining the applicability of a rule to workloads in that namespace.
         */
        sourceNamespace?: string;
        [k: string]: unknown;
      }[];
      /**
       * The destination to which the connection should be forwarded to.
       */
      route?: {
        destination?: {
          /**
           * The name of a service from the service registry.
           */
          host?: string;
          /**
           * Specifies the port on the host that is being addressed.
           */
          port?: {
            number?: number;
            [k: string]: unknown;
          };
          /**
           * The name of a subset within the service.
           */
          subset?: string;
          [k: string]: unknown;
        };
        weight?: number;
        [k: string]: unknown;
      }[];
      [k: string]: unknown;
    }[];
    [k: string]: unknown;
  };
  status?: {
    [k: string]: unknown;
  };
  apiVersion: "networking.istio.io/v1alpha3";
  kind: "VirtualService";
  [k: string]: unknown;
}
